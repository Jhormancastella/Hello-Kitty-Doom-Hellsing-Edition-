<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hello Kitty: Hell Edition</title>
    <link rel="icon" href="https://res.cloudinary.com/dipv76dpn/image/upload/v1761942565/b_Me_ayudas_crear_una__1_qnstkz.png" type="image/x-icon">
<style>
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        touch-action: manipulation;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
    }
    
    body {
        font-family: 'Comic Sans MS', cursive, Arial, sans-serif;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        background: linear-gradient(to bottom, #1a001a, #330033);
        overflow: hidden;
        color: white;
    }
    
    h1 {
        margin-bottom: 10px;
        text-align: center;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        font-size: 2.5rem;
        color: #ff6b9d;
    }
    
    #device-info {
        position: fixed;
        top: 15px;
        left: 15px;
        background-color: rgba(0, 0, 0, 0.6);
        color: #ff6b9d;
        padding: 8px 15px;
        border-radius: 20px;
        font-size: 12px;
        z-index: 100;
    }
    
    /* Pantalla de inicio */
    #splash-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(135deg, #2d1b3d, #1a0d26);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        transition: opacity 0.5s ease;
    }
    
    .game-title {
        text-align: center;
        font-size: 3.5rem;
        font-weight: bold;
        margin-bottom: 30px;
        text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.5);
        color: #ff6b9d;
        background: linear-gradient(45deg, #ff6b9d, #ff1744);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
    }
    
    .start-button {
        padding: 15px 40px;
        font-size: 1.5rem;
        background: linear-gradient(135deg, #ff6b9d, #ff1744);
        border: none;
        border-radius: 50px;
        color: white;
        cursor: pointer;
        box-shadow: 0 5px 15px rgba(255, 107, 157, 0.4);
        transition: transform 0.2s, box-shadow 0.2s;
        margin-bottom: 20px;
        font-weight: bold;
    }
    
    .start-button:hover {
        transform: translateY(-3px);
        box-shadow: 0 8px 20px rgba(255, 107, 157, 0.6);
    }
    
    .controls-info {
        margin-top: 30px;
        text-align: center;
        font-size: 1.2rem;
        max-width: 80%;
        line-height: 1.6;
        color: #ccc;
    }
    
    /* Selector de dificultad */
    .difficulty-selector {
        display: flex;
        gap: 15px;
        margin: 20px 0;
    }
    
    .difficulty-btn {
        padding: 10px 20px;
        background: rgba(255, 107, 157, 0.2);
        border: 2px solid #ff6b9d;
        border-radius: 30px;
        color: #ff6b9d;
        cursor: pointer;
        transition: all 0.3s;
        font-weight: bold;
    }
    
    .difficulty-btn.active {
        background: #ff6b9d;
        color: white;
        transform: scale(1.1);
    }
    
    /* Barra de estado para móvil */
    .mobile-status-bar {
        display: none;
        justify-content: space-between;
        align-items: center;
        width: 90%;
        max-width: 500px;
        margin: 0 auto 15px auto;
        padding: 10px 15px;
        background: rgba(0, 0, 0, 0.8);
        border-radius: 15px;
        border: 2px solid #ff6b9d;
        z-index: 50;
    }
    
    .status-item {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 14px;
        color: #ff6b9d;
        font-weight: bold;
    }
    
    .status-icon {
        font-size: 18px;
        width: 24px;
        text-align: center;
    }
    
    /* Estilos para el Mini Mapa */
    .mini-map {
        position: absolute;
        bottom: 20px;
        right: 20px;
        background: rgba(0, 0, 0, 0.8);
        border: 2px solid #ff6b9d;
        border-radius: 10px;
        padding: 8px;
        z-index: 90;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(5px);
    }
    
    .mini-map-title {
        text-align: center;
        font-size: 10px;
        color: #ff6b9d;
        margin-bottom: 5px;
        font-weight: bold;
    }
    
    #mini-map-canvas {
        display: block;
        border: 1px solid #ff6b9d;
        border-radius: 5px;
    }
    
    /* Indicador de arma actual */
    .weapon-display {
        position: absolute;
        bottom: 20px;
        left: 20px;
        background: rgba(0, 0, 0, 0.8);
        border: 2px solid #ff6b9d;
        border-radius: 10px;
        padding: 8px 12px;
        z-index: 90;
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 12px;
        color: #ff6b9d;
        font-weight: bold;
    }
    
    .weapon-icon {
        width: 24px;
        height: 24px;
        background-size: contain;
        background-repeat: no-repeat;
        background-position: center;
    }
    
    /* Estilos para móvil */
    .mobile-layout {
        display: none;
        position: relative;
        width: 100%;
        max-width: 500px;
    }
    
    .console-body {
        position: relative;
        width: 100%;
        height: 600px;
        background: linear-gradient(to bottom, #ff6b9d, #ff1744);
        border-radius: 30px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.6);
        overflow: hidden;
        padding: 20px;
        border: 8px solid #2d1b3d;
    }
    
    .console-screen-area {
        width: 90%;
        height: 55%;
        background-color: #1a1a2e;
        margin: 10px auto;
        border-radius: 15px;
        border: 6px solid #2d1b3d;
        box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        overflow: hidden;
        position: relative;
    }
    
    .console-controls {
        display: flex;
        justify-content: space-between;
        margin-top: 15px;
    }
    
    .d-pad {
        width: 150px;
        height: 150px;
        position: relative;
    }
    
    .d-pad-center {
        position: absolute;
        width: 60px;
        height: 60px;
        background-color: #7f8c8d;
        border-radius: 50%;
        top: 45px;
        left: 45px;
        z-index: 2;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
    }
    
    .d-pad-btn {
        position: absolute;
        width: 50px;
        height: 50px;
        background-color: #7f8c8d;
        display: flex;
        justify-content: center;
        align-items: center;
        color: white;
        font-size: 24px;
        font-weight: bold;
        border-radius: 10px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
        z-index: 1;
        cursor: pointer;
    }
    
    .d-pad-up { top: 0; left: 50px; }
    .d-pad-down { bottom: 0; left: 50px; }
    .d-pad-left { top: 50px; left: 0; }
    .d-pad-right { top: 50px; right: 0; }
    
    .action-buttons {
        display: flex;
        gap: 8px;
        align-items: center;
    }
    
    .action-btn {
        width: 70px;
        height: 70px;
        border-radius: 50%;
        background: linear-gradient(to bottom, #ff6b9d, #ff1744);
        display: flex;
        justify-content: center;
        align-items: center;
        color: white;
        font-size: 18px;
        font-weight: bold;
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        border: 3px solid #2d1b3d;
        cursor: pointer;
    }
    
    #btn-shoot { background: linear-gradient(to bottom, #ff1744, #d50000); }
    #btn-pause { width: 60px; height: 60px; background: linear-gradient(to bottom, #f39c12, #e67e22); font-size: 16px; }
    
    .power-light {
        position: absolute;
        top: 20px;
        right: 20px;
        width: 15px;
        height: 15px;
        border-radius: 50%;
        background-color: #ff6b9d;
        box-shadow: 0 0 10px #ff6b9d;
        animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.5; }
    }
    
    .brand {
        position: absolute;
        top: 10px;
        left: 20px;
        color: white;
        font-weight: bold;
        font-size: 18px;
        z-index: 5;
    }
    
    /* Estilos para escritorio con efecto TV CRT */
    .desktop-layout {
        display: none;
        width: 100%;
        height: 100vh;
        position: fixed;
        top: 0;
        left: 0;
        overflow: hidden;
        background: #000;
        z-index: 1;
    }
    
    .crt-tv {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 1200px;
        height: 800px;
        background: transparent;
        border-radius: 20px;
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10;
        pointer-events: none;
        box-shadow: 0 0 50px rgba(255, 107, 157, 0.3);
        background-image: url('https://res.cloudinary.com/dipv76dpn/image/upload/v1758056110/Rosy/pv7fuibuyi79xza62szr.png');
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        border: 15px solid transparent;
    }
    
    .tv-screen {
        width: 800px;
        height: 600px;
        background: #000;
        border-radius: 4px;
        overflow: hidden;
        position: relative;
        border: 8px solid #1a1a1a;
        box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.8);
    }
    
    #desktop-canvas {
        width: 100%;
        height: 100%;
        display: block;
    }
    
    /* Efectos CRT mejorados */
    .crt-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(rgba(18, 16, 16, 0.1) 50%, rgba(0, 0, 0, 0.1) 50%);
        background-size: 100% 4px;
        z-index: 20;
        pointer-events: none;
    }
    
    .crt-scanlines {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(to bottom, rgba(255, 107, 157, 0.03) 50%, rgba(0, 0, 0, 0.1) 50%);
        background-size: 100% 4px;
        z-index: 20;
        pointer-events: none;
    }
    
    .crt-reflection {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0) 60%);
        z-index: 20;
        pointer-events: none;
    }
    
    .crt-glow {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        box-shadow: inset 0 0 50px rgba(255, 107, 157, 0.1);
        z-index: 20;
        pointer-events: none;
    }
    
    /* Efecto de curvatura de pantalla CRT */
    .crt-curvature {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        border-radius: 10px;
        box-shadow: 
            inset 0 0 60px rgba(0, 0, 0, 0.9),
            inset 0 0 30px rgba(0, 0, 0, 0.6);
        z-index: 15;
        pointer-events: none;
    }
    
    .tv-frame {
        display: none;
    }
    
    #score, #health, #ammo, #wave {
        position: fixed;
        background-color: rgba(0, 0, 0, 0.8);
        color: #ff6b9d;
        padding: 8px 15px;
        border-radius: 20px;
        font-size: 16px;
        z-index: 100;
        border: 2px solid #ff6b9d;
    }
    
    #score { top: 15px; right: 15px; }
    #health { top: 15px; left: 50%; transform: translateX(-50%); font-size: 12px; }
    #ammo { top: 60px; left: 50%; transform: translateX(-50%); }
    #wave { top: 100px; left: 50%; transform: translateX(-50%); font-size: 14px; }
    
    .instructions {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background-color: rgba(0, 0, 0, 0.8);
        color: #ff6b9d;
        padding: 10px 20px;
        border-radius: 20px;
        font-size: 16px;
        text-align: center;
        z-index: 100;
        border: 2px solid #ff6b9d;
    }
    
    /* Modal de pausa */
    #pause-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.8);
        display: none;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 200;
    }
    
    .pause-content {
        background: linear-gradient(135deg, #2d1b3d, #1a0d26);
        padding: 30px;
        border-radius: 20px;
        text-align: center;
        box-shadow: 0 10px 30px rgba(255, 107, 157, 0.5);
        max-width: 80%;
        border: 2px solid #ff6b9d;
    }
    
    .pause-title {
        font-size: 2.5rem;
        margin-bottom: 20px;
        color: #ff6b9d;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    }
    
    .resume-button {
        padding: 12px 30px;
        font-size: 1.2rem;
        background: linear-gradient(135deg, #ff6b9d, #ff1744);
        border: none;
        border-radius: 50px;
        color: white;
        cursor: pointer;
        box-shadow: 0 5px 15px rgba(255, 107, 157, 0.3);
        margin-top: 15px;
        font-weight: bold;
    }
    
    /* Efectos de pulsación */
    .d-pad-btn:active, .action-btn:active, .start-button:active, .resume-button:active, .difficulty-btn:active {
        transform: translateY(4px) scale(0.95);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
    }
    
    /* Responsive */
    @media (max-width: 360px) {
        .mini-map {
            bottom: 15px;
            right: 15px;
            padding: 6px;
        }
        
        #mini-map-canvas {
            width: 80px !important;
            height: 80px !important;
        }
        
        .mini-map-title {
            font-size: 8px;
        }
        
        .weapon-display {
            bottom: 15px;
            left: 15px;
            padding: 6px 10px;
            font-size: 10px;
        }
        
        .weapon-icon {
            width: 20px;
            height: 20px;
        }
        
        .brand {
            font-size: 14px;
            top: 15px;
            left: 15px;
        }
    }
    
    @media (max-width: 768px) {
        .mobile-layout { display: block; }
        .mobile-status-bar { display: flex; }
        h1 { 
            font-size: 1.8rem; 
            margin-bottom: 5px;
            margin-top: 10px;
        }
        .game-title { font-size: 2.5rem; }
        .d-pad { width: 120px; height: 120px; }
        .d-pad-center { width: 50px; height: 50px; top: 35px; left: 35px; }
        .d-pad-btn { width: 40px; height: 40px; font-size: 18px; }
        .d-pad-up, .d-pad-down { left: 40px; }
        .d-pad-left, .d-pad-right { top: 40px; }
        .action-btn { width: 35px; height: 35px; font-size: 12px; }
        #btn-pause { width: 50px; height: 50px; font-size: 14px; }
        
        .mini-map {
            bottom: 15px;
            right: 15px;
        }
        
        #mini-map-canvas {
            width: 100px;
            height: 100px;
        }
        
        .weapon-display {
            bottom: 15px;
            left: 15px;
            font-size: 11px;
        }
        
        #health, #ammo, #wave, #score {
            display: none !important;
        }
        
        .console-screen-area {
            margin: 5px auto;
            height: 58%;
        }
        
        .brand {
            font-size: 16px;
            top: 12px;
            left: 18px;
        }
    }
    
    @media (min-width: 769px) and (max-width: 1024px) {
        .mini-map {
            bottom: 25px;
            right: 25px;
        }
        
        #mini-map-canvas {
            width: 150px;
            height: 150px;
        }
        
        .weapon-display {
            bottom: 25px;
            left: 25px;
        }
        
        .crt-tv {
            width: 900px;
            height: 650px;
        }
        
        .tv-screen {
            width: 700px;
            height = 500px;
        }
    }
    
    @media (min-width: 1025px) {
        .desktop-layout { display: block; }
        body { padding: 0; overflow: hidden; }
        .mobile-status-bar { display: none !important; }
        
        .mini-map {
            bottom: 30px;
            right: 30px;
        }
        
        #mini-map-canvas {
            width: 200px;
            height: 200px;
        }
        
        .mini-map-title {
            font-size: 12px;
        }
        
        .weapon-display {
            bottom: 30px;
            left: 30px;
            font-size: 14px;
        }
    }

    .console-controls, .d-pad, .d-pad-btn, .action-buttons, .action-btn {
        touch-action: none !important;
    }

    #mobile-canvas { touch-action: none; }

    .d-pad-btn.pressed {
        background-color: #ff1744 !important;
        transform: scale(1.1);
    }

    /* Estilos para el indicador de jefe */
    .boss-warning {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(255, 0, 0, 0.9);
        color: white;
        padding: 20px 40px;
        border-radius: 15px;
        font-size: 2rem;
        font-weight: bold;
        text-align: center;
        z-index: 300;
        animation: bossWarning 2s ease-in-out;
        box-shadow: 0 0 30px rgba(255, 0, 0, 0.7);
        border: 3px solid #ff6b9d;
    }

    @keyframes bossWarning {
        0%, 100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
        50% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
    }
</style>
</head>
<body>
    <h1>Hello Kitty: Hell Edition</h1>
    
    <div class="mobile-status-bar">
        <div class="status-item">
            <span class="status-icon">♥</span>
            <span id="mobile-health">100</span>
        </div>
        <div class="status-item">
            <span class="status-icon">🔫</span>
            <span id="mobile-ammo">100</span>
        </div>
        <div class="status-item">
            <span class="status-icon">🚩</span>
            <span id="mobile-wave">1</span>
        </div>
        <div class="status-item">
            <span class="status-icon">⭐</span>
            <span id="mobile-score">0</span>
        </div>
    </div>
    
    <div id="device-info">Dispositivo: Detectando...</div>
    
    <div id="splash-screen">
        <img src="https://res.cloudinary.com/dipv76dpn/image/upload/v1761942565/b_Me_ayudas_crear_una__1_qnstkz.png" alt="Logo del Juego" width="150" height="150" style="margin-bottom: 20px; border-radius: 20px; border: 3px solid #ff6b9d; box-shadow: 0 0 20px rgba(255, 107, 157, 0.5);">
        <div class="game-title">HELLO KITTY: HELL EDITION</div>
        
        <div class="difficulty-selector">
            <div class="difficulty-btn active" data-difficulty="easy">FÁCIL</div>
            <div class="difficulty-btn" data-difficulty="medium">NORMAL</div>
            <div class="difficulty-btn" data-difficulty="hard">DIFÍCIL</div>
            <div class="difficulty-btn" data-difficulty="nightmare">PESADILLA</div>
        </div>
        
        <button class="start-button" id="start-button">INICIAR JUEGO</button>
        <div class="controls-info" id="controls-info"></div>
    </div>
    
    <div class="mobile-layout">
        <div class="console-body">
            <div class="brand">Rosy-Consola</div>
            <div class="power-light"></div>
            
            <div class="console-screen-area">
                <canvas id="mobile-canvas"></canvas>
                
                <div class="mini-map">
                    <div class="mini-map-title">MAPA</div>
                    <canvas id="mini-map-canvas"></canvas>
                </div>
                
                <div class="weapon-display" id="weapon-display">
                    <div class="weapon-icon" id="weapon-icon"></div>
                    <span id="weapon-name">PISTOLA</span>
                </div>
                
                <div id="score">PUNTOS: 0</div>
                <div id="health">VIDA: 100</div>
                <div id="ammo">MUNICIÓN: 100</div>
                <div id="wave">OLEADA: 1</div>
            </div>
            
            <div class="console-controls">
                <div class="d-pad">
                    <div class="d-pad-btn d-pad-up" id="up-btn">↑</div>
                    <div class="d-pad-btn d-pad-down" id="down-btn">↓</div>
                    <div class="d-pad-btn d-pad-left" id="left-btn">←</div>
                    <div class="d-pad-btn d-pad-right" id="right-btn">→</div>
                    <div class="d-pad-center"></div>
                </div>
                
                <div class="action-buttons">
                    <div class="action-btn" id="btn-pause">P</div>
                    <div class="action-btn" id="btn-shoot">B</div>
                    <div class="action-btn" id="btn-action">A</div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="desktop-layout">
        <div class="crt-tv">
            <div class="tv-screen">
                <canvas id="desktop-canvas"></canvas>
                
                <div class="mini-map">
                    <div class="mini-map-title">MAPA DEL INFIERNO</div>
                    <canvas id="desktop-mini-map"></canvas>
                </div>
                
                <div class="weapon-display" id="desktop-weapon-display">
                    <div class="weapon-icon" id="desktop-weapon-icon"></div>
                    <span id="desktop-weapon-name">PISTOLA</span>
                </div>
                
                <div class="crt-curvature"></div>
                <div class="crt-overlay"></div>
                <div class="crt-scanlines"></div>
                <div class="crt-reflection"></div>
                <div class="crt-glow"></div>
            </div>
        </div>
        <div id="score">PUNTOS: 0</div>
        <div id="health">VIDA: 100</div>
        <div id="ammo">MUNICIÓN: 100</div>
        <div id="wave">OLEADA: 1</div>
        <div id="pause-btn">PAUSA [P]</div>
        <div class="instructions">Usa WASD para mover, Q/E para rotar, Barra espaciadora para disparar, P para pausar</div>
    </div>

    <div id="pause-modal">
        <div class="pause-content">
            <div class="pause-title">JUEGO EN PAUSA</div>
            <p>Presiona continuar para reanudar la diversión mortal</p>
            <button class="resume-button" id="resume-button">CONTINUAR</button>
        </div>
    </div>

    <script>
    // =============================================
    // SISTEMA DE SONIDO MEJORADO
    // =============================================
    class SoundSystem {
        constructor() {
            this.audioContext = null;
            this.masterVolume = 0.3;
            this.enabled = true;
            this.backgroundPlaying = false;
            this.initAudio();
        }
        
        initAudio() {
            try {
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            } catch (e) {
                this.enabled = false;
            }
        }
        
        createOscillator(frequency, type = 'sine', duration = 0.2) {
            if (!this.enabled || !this.audioContext) return;
            const oscillator = this.audioContext.createOscillator();
            const gainNode = this.audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(this.audioContext.destination);
            oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
            oscillator.type = type;
            gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(this.masterVolume, this.audioContext.currentTime + 0.01);
            gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration);
            oscillator.start(this.audioContext.currentTime);
            oscillator.stop(this.audioContext.currentTime + duration);
        }
        
        playShoot() { this.createOscillator(200, 'square', 0.1); }
        playHit() { this.createOscillator(150, 'sawtooth', 0.4); }
        playPickup() { [523, 659, 784].forEach((f, i) => setTimeout(() => this.createOscillator(f, 'sine', 0.15), i * 50)); }
        playHurt() { this.createOscillator(100, 'sawtooth', 0.3); }
        playWaveComplete() { [523, 659, 784, 1047].forEach((f, i) => setTimeout(() => this.createOscillator(f, 'sine', 0.5), i * 200)); }
        playGameOver() { [392, 349, 311, 262].forEach((f, i) => setTimeout(() => this.createOscillator(f, 'triangle', 0.6), i * 300)); }
        playWeaponSwitch() { [392, 494, 587].forEach((f, i) => setTimeout(() => this.createOscillator(f, 'sine', 0.1), i * 80)); }
        playHealthPickup() { [330, 392, 494].forEach((f, i) => setTimeout(() => this.createOscillator(f, 'sine', 0.2), i * 100)); }
        playBossSpawn() { 
            [196, 220, 247, 262, 294, 330, 349, 392, 440, 494, 523].forEach((f, i) => 
                setTimeout(() => this.createOscillator(f, 'sawtooth', 0.3), i * 100)
            ); 
        }
        playBossHit() { this.createOscillator(80, 'square', 0.5); }
        
        playBackgroundMusic() {
            if (this.backgroundPlaying) return;
            this.backgroundPlaying = true;
            const melody = [262, 294, 330, 349, 392, 440, 494, 523];
            let i = 0;
            const play = () => {
                if (!this.backgroundPlaying) return;
                this.createOscillator(melody[i], 'sine', 1.2);
                i = (i + 1) % melody.length;
                setTimeout(play, 1500);
            };
            play();
        }
        
        stopBackgroundMusic() { this.backgroundPlaying = false; }
        toggleSound() { return this.enabled = !this.enabled; }
    }
    
    const soundSystem = new SoundSystem();

    // =============================================
    // DETECCIÓN DE DISPOSITIVO
    // =============================================
    const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) || window.innerWidth <= 768;
    const deviceInfo = document.getElementById('device-info');
    const controlsInfo = document.getElementById('controls-info');
    
    if (isMobile) {
        deviceInfo.textContent = "Dispositivo: Móvil (Modo Game Boy)";
        controlsInfo.innerHTML = "CRUCETA: ↑↓ para avanzar/retroceder, ←→ para rotar<br>BOTÓN B: Disparar, BOTÓN A: Acción, BOTÓN P: Pausar";
    } else {
        deviceInfo.textContent = "Dispositivo: Escritorio (Modo TV CRT)";
        controlsInfo.innerHTML = "Usa WASD para moverte, Q/E para rotar<br>Barra espaciadora para disparar, P para pausar";
    }
    
    // =============================================
    // VARIABLES GLOBALES DEL JUEGO
    // =============================================
    let gameStarted = false, gamePaused = false, currentDifficulty = 'easy';
    let animationFrameId;
    let textures = {};
    let lastTime = 0;
    let shootCooldown = 0;
    let damageEffectTimer = 0;
    let bossWarningTimer = 0;

    const splashScreen = document.getElementById('splash-screen');
    const startButton = document.getElementById('start-button');
    const pauseModal = document.getElementById('pause-modal');
    const resumeButton = document.getElementById('resume-button');
    const pauseBtn = document.getElementById('pause-btn');
    const difficultyButtons = document.querySelectorAll('.difficulty-btn');
    
    let canvas, ctx, miniMapCanvas, miniMapCtx;
    if (isMobile) {
        canvas = document.getElementById('mobile-canvas');
        miniMapCanvas = document.getElementById('mini-map-canvas');
    } else {
        canvas = document.getElementById('desktop-canvas');
        miniMapCanvas = document.getElementById('desktop-mini-map');
    }
    ctx = canvas.getContext('2d');
    miniMapCtx = miniMapCanvas.getContext('2d');

    // =============================================
    // SISTEMA DE ARMAS CORREGIDO
    // =============================================
    const weapons = {
        pistol: {
            name: "PISTOLA",
            damage: 25,
            ammoCost: 1,
            cooldown: 0.2,
            texture: 'https://res.cloudinary.com/dipv76dpn/image/upload/v1761931100/Photoroom-20251031_120316_3_i1i8kj.png',
            icon: 'https://res.cloudinary.com/dipv76dpn/image/upload/v1761931100/Photoroom-20251031_120316_3_i1i8kj.png'
        },
        shotgun: {
            name: "ESCOPETA", 
            damage: 40,
            ammoCost: 2,
            cooldown: 0.8,
            spread: 0.2,
            texture: 'https://res.cloudinary.com/dipv76dpn/image/upload/v1761931101/Photoroom-20251031_120316_5_osprby.png',
            icon: 'https://res.cloudinary.com/dipv76dpn/image/upload/v1761931101/Photoroom-20251031_120316_5_osprby.png'
        },
        rifle: {
            name: "RIFLE",
            damage: 35,
            ammoCost: 1,
            cooldown: 0.1,
            texture: 'https://res.cloudinary.com/dipv76dpn/image/upload/v1761931101/Photoroom-20251031_120316_6_tflii5.png',
            icon: 'https://res.cloudinary.com/dipv76dpn/image/upload/v1761931101/Photoroom-20251031_120316_6_tflii5.png'
        }
    };

    // =============================================
    // SISTEMA DE ITEMS
    // =============================================
    const itemTypes = {
        health: {
            texture: 'https://res.cloudinary.com/dipv76dpn/image/upload/v1761931100/Photoroom-20251031_120315_1_vwz2bq.png',
            value: 25,
            sound: 'playHealthPickup'
        },
        ammo: {
            texture: 'https://res.cloudinary.com/dipv76dpn/image/upload/v1761931100/Photoroom-20251031_120316_2_nnf0u7.png',
            value: 30,
            sound: 'playPickup'
        },
        weapon: {
            textures: [
                'https://res.cloudinary.com/dipv76dpn/image/upload/v1761931100/Photoroom-20251031_120316_3_i1i8kj.png',
                'https://res.cloudinary.com/dipv76dpn/image/upload/v1761931101/Photoroom-20251031_120316_5_osprby.png',
                'https://res.cloudinary.com/dipv76dpn/image/upload/v1761931101/Photoroom-20251031_120316_6_tflii5.png'
            ],
            sound: 'playWeaponSwitch'
        }
    };

    // =============================================
    // SISTEMA DE ESTADO DEL JUEGO MEJORADO
    // =============================================
    class GameState {
        constructor() {
            this.reset();
        }
        
        reset() {
            this.player = {
                x: 1.5, y: 1.5, angle: 0, health: 100, ammo: 100,
                currentWeapon: 'pistol',
                weapons: ['pistol'],
                lastDamageTime: 0
            };
            this.score = 0;
            this.enemies = [];
            this.wave = 1;
            this.items = [];
            this.gameTime = 0;
            this.bossActive = false;
            this.bossDefeated = false;
        }
    }

    let gameData = new GameState();

    // =============================================
    // SISTEMA DE PARTÍCULAS OPTIMIZADO
    // =============================================
    class ParticleSystem {
        constructor(maxParticles = 1000) {
            this.particles = [];
            this.maxParticles = maxParticles;
        }
        
        createExplosion(x, y, count = 10) {
            const actualCount = Math.min(count, this.maxParticles - this.particles.length);
            for (let i = 0; i < actualCount; i++) {
                this.particles.push({ 
                    x, y, 
                    vx: (Math.random() - 0.5) * 0.1, 
                    vy: (Math.random() - 0.5) * 0.1, 
                    life: 1.0, 
                    decay: 0.02, 
                    color: `hsl(${Math.random() * 60}, 100%, 50%)` 
                });
            }
        }
        
        createItemPickup(x, y, color) {
            const actualCount = Math.min(8, this.maxParticles - this.particles.length);
            for (let i = 0; i < actualCount; i++) {
                this.particles.push({ 
                    x, y, 
                    vx: (Math.random() - 0.5) * 0.05, 
                    vy: (Math.random() - 0.5) * 0.05, 
                    life: 1.0, 
                    decay: 0.03, 
                    color: color 
                });
            }
        }

        createBossSpawn(x, y) {
            const actualCount = Math.min(50, this.maxParticles - this.particles.length);
            for (let i = 0; i < actualCount; i++) {
                const angle = (i / actualCount) * Math.PI * 2;
                this.particles.push({
                    x, y,
                    vx: Math.cos(angle) * 0.1,
                    vy: Math.sin(angle) * 0.1,
                    life: 1.0,
                    decay: 0.01,
                    color: `hsl(${Math.random() * 360}, 100%, 50%)`
                });
            }
        }
        
        update(deltaTime) { 
            this.particles = this.particles.filter(p => { 
                p.x += p.vx * deltaTime * 60; 
                p.y += p.vy * deltaTime * 60; 
                p.life -= p.decay * deltaTime * 60; 
                return p.life > 0; 
            }); 
        }
        
        render() { 
            ctx.save(); 
            this.particles.forEach(p => { 
                ctx.globalAlpha = p.life; 
                ctx.fillStyle = p.color; 
                ctx.fillRect(p.x * 20 - 2, p.y * 20 - 2, 4, 4); 
            }); 
            ctx.restore(); 
        }
    }
    
    let particleSystem = new ParticleSystem(1000);

    // =============================================
    // FUNCIONES DE UTILIDAD
    // =============================================
    function resizeCanvas() {
        if (isMobile) {
            const screenArea = document.querySelector('.console-screen-area');
            canvas.width = screenArea.clientWidth - 20;
            canvas.height = screenArea.clientHeight - 20;
            
            if (window.innerWidth <= 360) {
                miniMapCanvas.width = 80;
                miniMapCanvas.height = 80;
            } else {
                miniMapCanvas.width = 100;
                miniMapCanvas.height = 100;
            }
        } else {
            canvas.width = 800;
            canvas.height = 600;
            
            if (window.innerWidth <= 1024) {
                miniMapCanvas.width = 150;
                miniMapCanvas.height = 150;
            } else {
                miniMapCanvas.width = 200;
                miniMapCanvas.height = 200;
            }
        }
    }

    function updateScore(s) { 
        document.querySelectorAll('#score').forEach(d => d.textContent = `PUNTOS: ${s}`);
        if (isMobile) document.getElementById('mobile-score').textContent = s;
    }
    
    function updateHealth(h) { 
        document.querySelectorAll('#health').forEach(d => d.textContent = `VIDA: ${h}`);
        if (isMobile) document.getElementById('mobile-health').textContent = h;
    }
    
    function updateAmmo(a) { 
        document.querySelectorAll('#ammo').forEach(d => d.textContent = `MUNICIÓN: ${a}`);
        if (isMobile) document.getElementById('mobile-ammo').textContent = a;
    }
    
    function updateWave(w) { 
        document.querySelectorAll('#wave').forEach(d => d.textContent = `OLEADA: ${w}`);
        if (isMobile) document.getElementById('mobile-wave').textContent = w;
    }

    function updateWeaponDisplay() {
        const currentWeapon = weapons[gameData.player.currentWeapon];
        const weaponDisplay = isMobile ? document.getElementById('weapon-display') : document.getElementById('desktop-weapon-display');
        const weaponName = isMobile ? document.getElementById('weapon-name') : document.getElementById('desktop-weapon-name');
        const weaponIcon = isMobile ? document.getElementById('weapon-icon') : document.getElementById('desktop-weapon-icon');
        
        weaponName.textContent = currentWeapon.name;
        weaponIcon.style.backgroundImage = `url('${currentWeapon.icon}')`;
    }

    function showBossWarning() {
        const warning = document.createElement('div');
        warning.className = 'boss-warning';
        warning.textContent = '¡JEFE INMINENTE!';
        document.body.appendChild(warning);
        
        setTimeout(() => {
            document.body.removeChild(warning);
        }, 2000);
    }

    // =============================================
    // SISTEMA DE DIFICULTAD
    // =============================================
    const difficulties = {
        easy: { enemyCount: 3, enemyHealth: 50, enemySpeed: 0.008, ammoDrop: 30, waveBonus: 100, itemSpawnChance: 0.4 },
        medium: { enemyCount: 5, enemyHealth: 75, enemySpeed: 0.012, ammoDrop: 20, waveBonus: 200, itemSpawnChance: 0.3 },
        hard: { enemyCount: 7, enemyHealth: 100, enemySpeed: 0.016, ammoDrop: 15, waveBonus: 300, itemSpawnChance: 0.25 },
        nightmare: { enemyCount: 10, enemyHealth: 150, enemySpeed: 0.020, ammoDrop: 10, waveBonus: 500, itemSpawnChance: 0.2 }
    };

    difficultyButtons.forEach(btn => btn.addEventListener('click', () => {
        difficultyButtons.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentDifficulty = btn.dataset.difficulty;
    }));

    // =============================================
    // SISTEMA DE COLISIONES MEJORADO
    // =============================================
    class CollisionSystem {
        static checkMapCollision(x, y, radius = 0.3) {
            const gridX = Math.floor(x);
            const gridY = Math.floor(y);
            
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const checkX = gridX + dx;
                    const checkY = gridY + dy;
                    
                    if (map[checkY] && map[checkY][checkX] === 1) {
                        const tileCenterX = checkX + 0.5;
                        const tileCenterY = checkY + 0.5;
                        const distance = Math.hypot(x - tileCenterX, y - tileCenterY);
                        
                        if (distance < radius + 0.5) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        
        static isValidPosition(x, y, radius = 0.3) {
            return !this.checkMapCollision(x, y, radius);
        }
    }

    // =============================================
    // MAPA DEL JUEGO
    // =============================================
    const map = [
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,1,0,1,1,1,0,1,1,1,0,1,1,0,1],
        [1,0,1,0,0,0,1,0,1,0,0,0,1,0,0,1],
        [1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1],
        [1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,1],
        [1,1,1,0,1,0,1,1,1,0,1,0,1,1,0,1],
        [1,0,0,0,0,0,0,0,1,0,0,0,0,1,0,1],
        [1,0,1,1,1,1,1,0,1,1,1,1,0,1,0,1],
        [1,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1],
        [1,1,1,1,1,0,1,1,1,1,0,1,1,1,0,1],
        [1,0,0,0,1,0,0,0,0,1,0,0,0,1,0,1],
        [1,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1],
        [1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,1],
        [1,0,0,0,1,1,0,0,0,1,0,0,0,0,0,1],
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
    ];

    // =============================================
    // FUNCIONES DE ITEMS
    // =============================================
    function spawnItem(type, x, y) {
        const item = {
            x: x,
            y: y,
            type: type,
            collected: false,
            spawnTime: Date.now()
        };
        
        if (type === 'weapon') {
            const availableWeapons = Object.keys(weapons).filter(w => !gameData.player.weapons.includes(w));
            if (availableWeapons.length > 0) {
                item.weaponType = availableWeapons[Math.floor(Math.random() * availableWeapons.length)];
                item.texture = itemTypes.weapon.textures[Object.keys(weapons).indexOf(item.weaponType) % itemTypes.weapon.textures.length];
            } else {
                return null;
            }
        }
        
        gameData.items.push(item);
        return item;
    }

    function spawnRandomItem() {
        const diff = difficulties[currentDifficulty];
        if (Math.random() < diff.itemSpawnChance) {
            let x, y;
            let attempts = 0;
            do {
                x = Math.floor(Math.random() * (map[0].length - 2)) + 1;
                y = Math.floor(Math.random() * (map.length - 2)) + 1;
                attempts++;
            } while ((map[y][x] !== 0 || 
                     Math.abs(x - gameData.player.x) < 2 || 
                     Math.abs(y - gameData.player.y) < 2) && attempts < 50);
            
            if (attempts < 50) {
                const itemTypes = ['health', 'ammo', 'weapon'];
                const weights = [0.4, 0.4, 0.2];
                let random = Math.random();
                let selectedType = 'health';
                
                if (random < weights[0]) selectedType = 'health';
                else if (random < weights[0] + weights[1]) selectedType = 'ammo';
                else selectedType = 'weapon';
                
                spawnItem(selectedType, x + 0.5, y + 0.5);
            }
        }
    }

    // =============================================
    // CARGAR TEXTURAS (INCLUYENDO JEFES)
    // =============================================
    async function loadTextures() {
        const textureSources = {
            wall: 'https://res.cloudinary.com/dipv76dpn/image/upload/w_256,h_256,c_fill/v1761769077/b_M%C3%A1s_tipo_met%C3%A1lico_un_mhb1gg.png',
            enemy: 'https://res.cloudinary.com/dipv76dpn/image/upload/v1761849704/de24431f-418a-4ffa-b40c-58d6eec4fb48_yg9n2n.png',
            floor: 'https://res.cloudinary.com/dipv76dpn/image/upload/v1761769080/techo0_gqwtwh.jpg',
            health: 'https://res.cloudinary.com/dipv76dpn/image/upload/v1761931100/Photoroom-20251031_120315_1_vwz2bq.png',
            ammo: 'https://res.cloudinary.com/dipv76dpn/image/upload/v1761931100/Photoroom-20251031_120316_2_nnf0u7.png',
            weapon1: 'https://res.cloudinary.com/dipv76dpn/image/upload/v1761931100/Photoroom-20251031_120316_3_i1i8kj.png',
            weapon2: 'https://res.cloudinary.com/dipv76dpn/image/upload/v1761931101/Photoroom-20251031_120316_5_osprby.png',
            weapon3: 'https://res.cloudinary.com/dipv76dpn/image/upload/v1761931101/Photoroom-20251031_120316_6_tflii5.png',
            playerWeapon: 'https://res.cloudinary.com/dipv76dpn/image/upload/v1761931100/descarga_4_fbm3t4.png',
            // NUEVAS TEXTURAS DE JEFES
            boss1: 'https://res.cloudinary.com/dipv76dpn/image/upload/v1761952986/Photoroom-20251031_182239_1_j4ttbk.png',
            boss2: 'https://res.cloudinary.com/dipv76dpn/image/upload/v1761952985/Photoroom-20251031_182239_2_xszjso.png'
        };

        const loadPromises = Object.entries(textureSources).map(([key, url]) => {
            return new Promise(resolve => {
                const img = new Image();
                img.crossOrigin = "anonymous";
                img.onload = () => { textures[key] = img; resolve(); };
                img.onerror = () => {
                    const c = document.createElement('canvas');
                    c.width = c.height = 64;
                    const ctx = c.getContext('2d');
                    ctx.fillStyle = '#ff1744'; ctx.fillRect(0,0,64,64);
                    ctx.fillStyle = 'white'; ctx.font = '12px Arial'; ctx.fillText(key.toUpperCase(), 5, 35);
                    textures[key] = c;
                    resolve();
                };
                img.src = url + '?t=' + Date.now();
            });
        });
        await Promise.all(loadPromises);
    }

    // =============================================
    // SISTEMA DE ARMAS Y ITEMS
    // =============================================
    function switchWeapon(weaponType) {
        if (gameData.player.weapons.includes(weaponType)) {
            gameData.player.currentWeapon = weaponType;
            updateWeaponDisplay();
            soundSystem.playWeaponSwitch();
            return true;
        }
        return false;
    }

    function collectItem(item) {
        if (item.collected) return false;
        
        item.collected = true;
        
        switch(item.type) {
            case 'health':
                gameData.player.health = Math.min(100, gameData.player.health + itemTypes.health.value);
                updateHealth(gameData.player.health);
                soundSystem.playHealthPickup();
                break;
                
            case 'ammo':
                gameData.player.ammo += itemTypes.ammo.value;
                updateAmmo(gameData.player.ammo);
                soundSystem.playPickup();
                break;
                
            case 'weapon':
                if (item.weaponType && !gameData.player.weapons.includes(item.weaponType)) {
                    gameData.player.weapons.push(item.weaponType);
                    switchWeapon(item.weaponType);
                    soundSystem.playWeaponSwitch();
                }
                break;
        }
        
        return true;
    }

    // =============================================
    // SISTEMA DE DISPARO MEJORADO
    // =============================================
    function shoot() {
        const currentWeapon = weapons[gameData.player.currentWeapon];
        
        if (shootCooldown > 0 || gameData.player.ammo < currentWeapon.ammoCost) return;
        
        const angle = gameData.player.angle;
        const dx = Math.cos(angle), dy = Math.sin(angle);
        let x = gameData.player.x, y = gameData.player.y;
        let hit = false;
        
        for (let i = 0; i < 50; i++) {
            x += dx * 0.2; y += dy * 0.2;
            if (map[Math.floor(y)] && map[Math.floor(y)][Math.floor(x)] > 0) { hit = true; break; }
            for (const e of gameData.enemies) {
                if (Math.hypot(e.x - x, e.y - y) < 0.6) { 
                    // SISTEMA DE RESISTENCIA A DISPAROS
                    if (e.boss) {
                        // Jefe necesita 12 disparos (doble resistencia)
                        if (!e.hitCount) e.hitCount = 0;
                        e.hitCount++;
                        if (e.hitCount >= 12) {
                            e.health -= currentWeapon.damage;
                            e.hitCount = 0;
                            soundSystem.playBossHit();
                        }
                    } else {
                        // Enemigos normales necesitan 6 disparos
                        if (!e.hitCount) e.hitCount = 0;
                        e.hitCount++;
                        if (e.hitCount >= 6) {
                            e.health -= currentWeapon.damage;
                            e.hitCount = 0;
                            soundSystem.playHit();
                        }
                    }
                    hit = true; 
                    break; 
                }
            }
            if (hit) break;
        }
        
        gameData.player.ammo -= currentWeapon.ammoCost;
        shootCooldown = currentWeapon.cooldown;
        soundSystem.playShoot();
        updateAmmo(gameData.player.ammo);
        if (hit) particleSystem.createExplosion(x, y, 5);
        controls.shoot = false;
    }

    // =============================================
    // RENDERIZADO DEL MINI MAPA
    // =============================================
    function renderMiniMap() {
        const cellSize = miniMapCanvas.width / map[0].length;
        const playerSize = Math.max(3, cellSize * 0.6);
        
        miniMapCtx.fillStyle = 'rgba(0, 0, 0, 0.9)';
        miniMapCtx.fillRect(0, 0, miniMapCanvas.width, miniMapCanvas.height);
        
        for (let y = 0; y < map.length; y++) {
            for (let x = 0; x < map[y].length; x++) {
                if (map[y][x] === 1) {
                    miniMapCtx.fillStyle = '#ff6b9d';
                } else {
                    miniMapCtx.fillStyle = '#333344';
                }
                miniMapCtx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                
                miniMapCtx.strokeStyle = 'rgba(255, 107, 157, 0.3)';
                miniMapCtx.lineWidth = 0.5;
                miniMapCtx.strokeRect(x * cellSize, y * cellSize, cellSize, cellSize);
            }
        }
        
        gameData.items.forEach(item => {
            if (!item.collected) {
                let color;
                switch(item.type) {
                    case 'health': color = '#00ff00'; break;
                    case 'ammo': color = '#ffff00'; break;
                    case 'weapon': color = '#ff00ff'; break;
                    default: color = '#ffffff';
                }
                miniMapCtx.fillStyle = color;
                miniMapCtx.beginPath();
                miniMapCtx.arc(item.x * cellSize, item.y * cellSize, playerSize * 0.5, 0, Math.PI * 2);
                miniMapCtx.fill();
            }
        });
        
        gameData.enemies.forEach(enemy => {
            if (enemy.boss) {
                miniMapCtx.fillStyle = '#ff00ff'; // Color morado para el jefe
            } else {
                miniMapCtx.fillStyle = '#ff1744';
            }
            miniMapCtx.beginPath();
            miniMapCtx.arc(enemy.x * cellSize, enemy.y * cellSize, playerSize * (enemy.boss ? 1.2 : 0.8), 0, Math.PI * 2);
            miniMapCtx.fill();
            
            const healthRatio = enemy.health / enemy.maxHealth;
            if (healthRatio < 1) {
                miniMapCtx.fillStyle = healthRatio > 0.5 ? '#00ff00' : healthRatio > 0.25 ? '#ffff00' : '#ff0000';
                miniMapCtx.fillRect(
                    enemy.x * cellSize - playerSize * 0.4,
                    enemy.y * cellSize - playerSize * 1.2,
                    playerSize * 0.8 * healthRatio,
                    2
                );
            }
        });
        
        miniMapCtx.fillStyle = '#00ff00';
        miniMapCtx.beginPath();
        miniMapCtx.arc(gameData.player.x * cellSize, gameData.player.y * cellSize, playerSize, 0, Math.PI * 2);
        miniMapCtx.fill();
        
        const directionLength = playerSize * 1.5;
        miniMapCtx.strokeStyle = '#00ff00';
        miniMapCtx.lineWidth = 2;
        miniMapCtx.beginPath();
        miniMapCtx.moveTo(gameData.player.x * cellSize, gameData.player.y * cellSize);
        miniMapCtx.lineTo(
            gameData.player.x * cellSize + Math.cos(gameData.player.angle) * directionLength,
            gameData.player.y * cellSize + Math.sin(gameData.player.angle) * directionLength
        );
        miniMapCtx.stroke();
        
        miniMapCtx.strokeStyle = '#ff6b9d';
        miniMapCtx.lineWidth = 2;
        miniMapCtx.strokeRect(0, 0, miniMapCanvas.width, miniMapCanvas.height);
    }

    // =============================================
    // SISTEMA DE RAYCASTING OPTIMIZADO
    // =============================================
    function castRay(angle) {
        const dx = Math.cos(angle), dy = Math.sin(angle);
        let mapX = Math.floor(gameData.player.x), mapY = Math.floor(gameData.player.y);
        const deltaX = Math.abs(1 / (dx || 0.0001)), deltaY = Math.abs(1 / (dy || 0.0001));
        let stepX = dx < 0 ? -1 : 1, stepY = dy < 0 ? -1 : 1;
        let sideDistX = dx < 0 ? (gameData.player.x - mapX) * deltaX : (mapX + 1 - gameData.player.x) * deltaX;
        let sideDistY = dy < 0 ? (gameData.player.y - mapY) * deltaY : (mapY + 1 - gameData.player.y) * deltaY;
        let hit = false;
        while (!hit) {
            if (sideDistX < sideDistY) { sideDistX += deltaX; mapX += stepX; } else { sideDistY += deltaY; mapY += stepY; }
            if (map[mapY] && map[mapY][mapX] > 0) hit = true;
        }
        return sideDistX < sideDistY ?
            (mapX - gameData.player.x + (1 - stepX)/2) / (dx || 0.0001) :
            (mapY - gameData.player.y + (1 - stepY)/2) / (dy || 0.0001);
    }

    function isEnemyVisible(enemy) {
        const dist = Math.hypot(enemy.x - gameData.player.x, enemy.y - gameData.player.y);
        if (dist > 15) return false;
        
        const angle = Math.atan2(enemy.y - gameData.player.y, enemy.x - gameData.player.x) - gameData.player.angle;
        const normAngle = ((angle + Math.PI) % (2 * Math.PI)) - Math.PI;
        const fov = Math.PI / 3;
        
        const adjustedFov = dist < 5 ? fov * 1.5 : fov;
        
        if (Math.abs(normAngle) > adjustedFov / 2 + 0.5) return false;
        
        const wallDist = castRay(gameData.player.angle - fov / 2 + (normAngle + fov / 2) / fov * fov);
        return dist < wallDist + 0.3;
    }

    // =============================================
    // SISTEMA DE RENDERIZADO MEJORADO (CON JEFES)
    // =============================================
    function renderItems() {
        if (!textures.health) return;
        
        const width = canvas.width, height = canvas.height, fov = Math.PI / 3;
        
        gameData.items.forEach(item => {
            if (item.collected) return;
            
            const dist = Math.hypot(item.x - gameData.player.x, item.y - gameData.player.y);
            if (dist > 8) return;
            
            const angle = Math.atan2(item.y - gameData.player.y, item.x - gameData.player.x) - gameData.player.angle;
            const normAngle = ((angle + Math.PI) % (2 * Math.PI)) - Math.PI;
            if (Math.abs(normAngle) > fov / 2 + 0.2) return;
            
            const screenX = width / 2 + (normAngle / (fov / 2)) * (width / 2);
            const scale = height / dist * 1.2;
            const h = scale, w = scale;
            const y = height / 2 - h / 2, x = screenX - w / 2;
            
            const wallDist = castRay(gameData.player.angle - fov / 2 + (screenX / width) * fov);
            if (dist > wallDist + 0.1) return;
            
            let texture;
            switch(item.type) {
                case 'health': texture = textures.health; break;
                case 'ammo': texture = textures.ammo; break;
                case 'weapon': 
                    texture = textures[item.texture === itemTypes.weapon.textures[0] ? 'weapon1' : 
                                  item.texture === itemTypes.weapon.textures[1] ? 'weapon2' : 'weapon3'];
                    break;
                default: texture = textures.health;
            }
            
            if (texture) {
                ctx.save();
                ctx.globalAlpha = Math.max(0.5, 1 - dist / 8);
                const blink = Math.sin(Date.now() * 0.005) > 0;
                if (blink) {
                    ctx.drawImage(texture, 0, 0, texture.width, texture.height, x, y, w, h);
                }
                ctx.restore();
            }
        });
    }

    function renderPlayerWeapon() {
        if (!textures.playerWeapon) return;
        
        const width = canvas.width, height = canvas.height;
        const scale = height * 0.3;
        const x = width / 2 - scale / 2;
        const y = height - scale;
        
        ctx.save();
        ctx.globalAlpha = 0.9;
        ctx.drawImage(textures.playerWeapon, 0, 0, textures.playerWeapon.width, textures.playerWeapon.height, x, y, scale, scale);
        
        if (controls.shoot) {
            ctx.translate(0, Math.sin(Date.now() * 0.1) * 5);
        }
        ctx.restore();
    }

    function renderSprites() {
        const width = canvas.width, height = canvas.height, fov = Math.PI / 3;
        const sprites = gameData.enemies.map(e => ({ e, dist: Math.hypot(e.x - gameData.player.x, e.y - gameData.player.y) })).sort((a, b) => b.dist - a.dist);
        
        for (const { e, dist } of sprites) {
            if (dist > 15) continue;
            
            const angle = Math.atan2(e.y - gameData.player.y, e.x - gameData.player.x) - gameData.player.angle;
            const normAngle = ((angle + Math.PI) % (2 * Math.PI)) - Math.PI;
            
            const adjustedFov = dist < 5 ? fov * 1.5 : fov;
            
            if (Math.abs(normAngle) > adjustedFov / 2 + 0.5) continue;
            
            const screenX = width / 2 + (normAngle / (fov / 2)) * (width / 2);
            
            // Escala diferente para jefes
            const baseScale = e.boss ? 2.5 : 1.8;
            const scale = height / dist * baseScale;
            const h = scale, w = scale;
            const y = height / 2 - h / 2, x = screenX - w / 2;
            
            const wallDist = castRay(gameData.player.angle - fov / 2 + (screenX / width) * fov);
            if (dist > wallDist + 0.3) continue;
            
            const healthRatio = e.health / e.maxHealth;
            ctx.save();
            
            let alpha = Math.max(0.4, 1 - dist / 15);
            if (!isEnemyVisible(e)) {
                alpha *= 0.6;
            }
            
            ctx.globalAlpha = alpha;
            
            // Efectos especiales para jefes
            if (e.boss) {
                if (e.health < e.maxHealth * 0.5) {
                    // Cambiar textura cuando está a mitad de vida
                    ctx.drawImage(textures.boss2, 0, 0, textures.boss2.width, textures.boss2.height, x, y, w, h);
                    // Efecto de furia
                    if (Math.sin(Date.now() * 0.02) > 0) {
                        ctx.filter = 'brightness(2) saturate(3)';
                    }
                } else {
                    ctx.drawImage(textures.boss1, 0, 0, textures.boss1.width, textures.boss1.height, x, y, w, h);
                }
                
                // Aura del jefe
                ctx.globalAlpha = 0.3;
                ctx.fillStyle = '#ff00ff';
                ctx.beginPath();
                ctx.arc(screenX, y + h/2, w/2 * 1.2, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = alpha;
            } else {
                if (e.health < 30 && Math.sin(Date.now() * 0.01) > 0) {
                    ctx.filter = 'brightness(1.8) saturate(2)';
                }
                ctx.drawImage(textures.enemy, 0, 0, textures.enemy.width, textures.enemy.height, x, y, w, h);
            }
            
            ctx.restore();
            
            // Barra de salud mejorada para jefes
            if (dist < (e.boss ? 12 : 8)) {
                const bw = w * (e.boss ? 1.2 : 0.8), bh = e.boss ? 10 : 6, by = y - (e.boss ? 25 : 15);
                ctx.fillStyle = 'rgba(0,0,0,0.6)'; 
                ctx.fillRect(screenX - bw/2, by, bw, bh);
                
                if (e.boss) {
                    // Barra de salud del jefe con colores especiales
                    const gradient = ctx.createLinearGradient(screenX - bw/2, by, screenX + bw/2, by);
                    gradient.addColorStop(0, '#ff0000');
                    gradient.addColorStop(0.5, '#ffff00');
                    gradient.addColorStop(1, '#00ff00');
                    ctx.fillStyle = gradient;
                } else {
                    ctx.fillStyle = `hsl(${healthRatio * 120}, 100%, 50%)`;
                }
                ctx.fillRect(screenX - bw/2, by, bw * healthRatio, bh);
            }
            
            if (!isEnemyVisible(e)) {
                ctx.save();
                ctx.globalAlpha = 0.2;
                ctx.fillStyle = e.boss ? '#ff00ff' : '#ff0000';
                ctx.beginPath();
                ctx.arc(screenX, y + h/2, w/2, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }
    }

    function renderDamageEffect() {
        if (damageEffectTimer > 0) {
            const intensity = damageEffectTimer / 1.0;
            ctx.fillStyle = `rgba(255, 0, 0, ${0.3 * intensity})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        } else if (gameData.player.health < 30) {
            const intensity = 0.3 * (1 - gameData.player.health / 30);
            ctx.fillStyle = `rgba(255, 0, 0, ${intensity})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
    }

    function renderBossWarning() {
        if (bossWarningTimer > 0) {
            const intensity = Math.sin(bossWarningTimer * 10) * 0.5 + 0.5;
            ctx.fillStyle = `rgba(255, 0, 255, ${0.2 * intensity})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = `rgba(255, 255, 255, ${intensity})`;
            ctx.font = 'bold 48px Comic Sans MS';
            ctx.textAlign = 'center';
            ctx.fillText('¡JEFE ACERCÁNDOSE!', canvas.width / 2, canvas.height / 2);
        }
    }

    function renderScene() {
        const w = canvas.width, h = canvas.height, fov = Math.PI / 3;
        
        // Optimización: Reducir número de rayos
        const rayStep = isMobile ? 1 : Math.max(1, Math.floor(w / 200));
        const rays = Math.floor(w / rayStep);
        
        ctx.fillStyle = '#000'; 
        ctx.fillRect(0, 0, w, h);
        
        const horizon = h / 2;
        for (let y = horizon; y < h; y++) { 
            const d = h / (2 * (y - horizon)); 
            const b = Math.max(0, 1 - d / 10) * 50 + 30; 
            ctx.fillStyle = `hsl(0, 50%, ${b}%)`; 
            ctx.fillRect(0, y, w, 1); 
        }
        for (let y = 0; y < horizon; y++) { 
            const b = Math.max(0, 1 - (horizon - y) / 10) * 30 + 10; 
            ctx.fillStyle = `hsl(300, 30%, ${b}%)`; 
            ctx.fillRect(0, y, w, 1); 
        }

        for (let i = 0; i < rays; i++) {
            const angle = gameData.player.angle - fov / 2 + i * (fov / rays);
            let mx = Math.floor(gameData.player.x), my = Math.floor(gameData.player.y);
            const dx = Math.cos(angle), dy = Math.sin(angle);
            const deltaX = Math.abs(1 / (dx || 0.0001)), deltaY = Math.abs(1 / (dy || 0.0001));
            let stepX = dx < 0 ? -1 : 1, stepY = dy < 0 ? -1 : 1;
            let sideDistX = dx < 0 ? (gameData.player.x - mx) * deltaX : (mx + 1 - gameData.player.x) * deltaX;
            let sideDistY = dy < 0 ? (gameData.player.y - my) * deltaY : (my + 1 - gameData.player.y) * deltaY;
            let hit = false, side;
            while (!hit) {
                if (sideDistX < sideDistY) { sideDistX += deltaX; mx += stepX; side = 0; } else { sideDistY += deltaY; my += stepY; side = 1; }
                if (map[my] && map[my][mx] > 0) hit = true;
            }
            const dist = side === 0 ? (mx - gameData.player.x + (1 - stepX)/2) / (dx || 0.0001) : (my - gameData.player.y + (1 - stepY)/2) / (dy || 0.0001);
            const lineH = h / Math.max(dist, 0.1);
            const start = Math.max(0, -lineH / 2 + h / 2), end = Math.min(h - 1, lineH / 2 + h / 2);
            let brightness = Math.max(0.2, 1 - dist / 10); if (side === 1) brightness *= 0.7;
            if (textures.wall) {
                let wallX = side === 0 ? gameData.player.y + dist * dy : gameData.player.x + dist * dx; wallX -= Math.floor(wallX);
                const texX = Math.floor(wallX * textures.wall.width);
                ctx.globalAlpha = brightness;
                ctx.drawImage(textures.wall, texX, 0, 1, textures.wall.height, i * rayStep, start, rayStep, end - start);
                ctx.globalAlpha = 1;
            }
        }
        
        renderSprites();
        renderItems();
        particleSystem.render();
        renderPlayerWeapon();
        renderDamageEffect();
        renderBossWarning();
        
        const grad = ctx.createRadialGradient(w/2, h/2, 0, w/2, h/2, Math.max(w, h)/2);
        grad.addColorStop(0.7, 'rgba(0,0,0,0)'); grad.addColorStop(1, 'rgba(0,0,0,0.4)');
        ctx.fillStyle = grad; ctx.fillRect(0, 0, w, h);
        
        if (!isMobile) { 
            ctx.fillStyle = 'rgba(255,107,157,0.03)'; 
            for (let y = 0; y < h; y += 2) ctx.fillRect(0, y, w, 1); 
        }
        
        renderMiniMap();
    }

    // =============================================
    // SISTEMA DE CONTROLES
    // =============================================
    let controls = { forward: false, backward: false, left: false, right: false, strafeLeft: false, strafeRight: false, shoot: false, action: false };

    if (isMobile) {
        const setupButton = (btn, control) => {
            const press = (e) => { e.preventDefault(); controls[control] = true; btn.classList.add('pressed'); };
            const release = () => { controls[control] = false; btn.classList.remove('pressed'); };
            btn.addEventListener('touchstart', press, { passive: false });
            btn.addEventListener('mousedown', press);
            btn.addEventListener('touchend', release, { passive: false });
            btn.addEventListener('touchcancel', release, { passive: false });
            btn.addEventListener('mouseup', release);
            btn.addEventListener('mouseleave', release);
        };
        setupButton(document.getElementById('up-btn'), 'forward');
        setupButton(document.getElementById('down-btn'), 'backward');
        setupButton(document.getElementById('left-btn'), 'left');
        setupButton(document.getElementById('right-btn'), 'right');
        setupButton(document.getElementById('btn-shoot'), 'shoot');
        setupButton(document.getElementById('btn-action'), 'action');
        document.getElementById('btn-pause').addEventListener('click', togglePause);
        
        document.getElementById('btn-action').addEventListener('click', () => {
            if (gameStarted && !gamePaused) {
                const currentIndex = gameData.player.weapons.indexOf(gameData.player.currentWeapon);
                const nextIndex = (currentIndex + 1) % gameData.player.weapons.length;
                switchWeapon(gameData.player.weapons[nextIndex]);
            }
        });
    } else {
        pauseBtn.addEventListener('click', togglePause);
        
        document.addEventListener('keydown', e => {
            if (!gameStarted || gamePaused) return;
            
            if (e.key === '1' && gameData.player.weapons.includes('pistol')) {
                switchWeapon('pistol');
            } else if (e.key === '2' && gameData.player.weapons.includes('shotgun')) {
                switchWeapon('shotgun');
            } else if (e.key === '3' && gameData.player.weapons.includes('rifle')) {
                switchWeapon('rifle');
            } else if (e.key === 'r' || e.key === 'R') {
                const currentIndex = gameData.player.weapons.indexOf(gameData.player.currentWeapon);
                const nextIndex = (currentIndex + 1) % gameData.player.weapons.length;
                switchWeapon(gameData.player.weapons[nextIndex]);
            }
        });
    }

    document.addEventListener('keydown', e => {
        if (e.key === 'p' || e.key === 'P') togglePause();
        if (!gameStarted || gamePaused) return;
        if (e.key === 'ArrowLeft' || e.key === 'a') controls.left = true;
        if (e.key === 'ArrowRight' || e.key === 'd') controls.right = true;
        if (e.key === 'ArrowUp' || e.key === 'w') controls.forward = true;
        if (e.key === 'ArrowDown' || e.key === 's') controls.backward = true;
        if (e.key === ' ') controls.shoot = true;
        if (e.key === 'q' || e.key === 'Q') controls.strafeLeft = true;
        if (e.key === 'e' || e.key === 'E') controls.strafeRight = true;
    });

    document.addEventListener('keyup', e => {
        if (e.key === 'ArrowLeft' || e.key === 'a') controls.left = false;
        if (e.key === 'ArrowRight' || e.key === 'd') controls.right = false;
        if (e.key === 'ArrowUp' || e.key === 'w') controls.forward = false;
        if (e.key === 'ArrowDown' || e.key === 's') controls.backward = false;
        if (e.key === ' ') controls.shoot = false;
        if (e.key === 'q' || e.key === 'Q') controls.strafeLeft = false;
        if (e.key === 'e' || e.key === 'E') controls.strafeRight = false;
    });

    function togglePause() {
        if (!gameStarted) return;
        gamePaused = !gamePaused;
        pauseModal.style.display = gamePaused ? 'flex' : 'none';
    }
    resumeButton.addEventListener('click', togglePause);

    // =============================================
    // SISTEMA DE ENEMIGOS Y JEFES
    // =============================================
    function spawnBoss() {
        let x, y;
        do { 
            x = Math.floor(Math.random() * (map[0].length - 2)) + 1; 
            y = Math.floor(Math.random() * (map.length - 2)) + 1; 
        } while (map[y][x] !== 0 || Math.abs(x - gameData.player.x) < 4 || Math.abs(y - gameData.player.y) < 4);
        
        const bossHealth = 300 + (gameData.wave * 50); // Vida extra para el jefe
        
        const boss = {
            x: x + 0.5, 
            y: y + 0.5, 
            health: bossHealth,
            maxHealth: bossHealth,
            speed: 0.015, // Más lento pero más resistente
            attackCooldown: 0,
            boss: true,
            hitCount: 0 // Contador de golpes para el sistema de resistencia
        };
        
        gameData.enemies.push(boss);
        gameData.bossActive = true;
        
        // Efectos especiales al spawnear el jefe
        soundSystem.playBossSpawn();
        particleSystem.createBossSpawn(boss.x, boss.y);
        showBossWarning();
        bossWarningTimer = 2.0; // 2 segundos de advertencia
        
        return boss;
    }

    function generateEnemies() {
        gameData.enemies = [];
        const diff = difficulties[currentDifficulty];
        
        // Cada 5 oleadas, spawnear un jefe en lugar de enemigos normales
        if (gameData.wave % 5 === 0) {
            spawnBoss();
            gameData.bossDefeated = false;
        } else {
            // Oleada normal
            for (let i = 0; i < diff.enemyCount + (gameData.wave * 2); i++) {
                let x, y;
                do { 
                    x = Math.floor(Math.random() * (map[0].length - 2)) + 1; 
                    y = Math.floor(Math.random() * (map.length - 2)) + 1; 
                } while (map[y][x] !== 0 || Math.abs(x - gameData.player.x) < 3 || Math.abs(y - gameData.player.y) < 3);
                gameData.enemies.push({ 
                    x: x + 0.5, y: y + 0.5, 
                    health: diff.enemyHealth + (gameData.wave * 10), 
                    maxHealth: diff.enemyHealth + (gameData.wave * 10), 
                    speed: diff.enemySpeed + (gameData.wave * 0.002), 
                    attackCooldown: 0,
                    hitCount: 0 // Contador de golpes para resistencia
                });
            }
            gameData.bossActive = false;
        }
        
        // Spawnear items
        for (let i = 0; i < 2; i++) {
            spawnRandomItem();
        }
    }

    // =============================================
    // ACTUALIZACIÓN DEL JUEGO OPTIMIZADA
    // =============================================
    function updateGame(deltaTime) {
        const moveSpeed = isMobile ? 0.08 : 0.08;
        const turnSpeed = isMobile ? 0.03 : 0.05;
        
        // Actualizar cooldowns y timers
        if (shootCooldown > 0) shootCooldown -= deltaTime;
        if (damageEffectTimer > 0) damageEffectTimer -= deltaTime;
        if (bossWarningTimer > 0) bossWarningTimer -= deltaTime;
        
        if (controls.left) gameData.player.angle -= turnSpeed * deltaTime * 60;
        if (controls.right) gameData.player.angle += turnSpeed * deltaTime * 60;
        
        let moveX = 0, moveY = 0;
        if (controls.forward) { 
            moveX += Math.cos(gameData.player.angle) * moveSpeed * deltaTime * 60; 
            moveY += Math.sin(gameData.player.angle) * moveSpeed * deltaTime * 60; 
        }
        if (controls.backward) { 
            moveX -= Math.cos(gameData.player.angle) * moveSpeed * deltaTime * 60; 
            moveY -= Math.sin(gameData.player.angle) * moveSpeed * deltaTime * 60; 
        }
        if (controls.strafeLeft) { 
            moveX += Math.cos(gameData.player.angle - Math.PI/2) * moveSpeed * 0.7 * deltaTime * 60; 
            moveY += Math.sin(gameData.player.angle - Math.PI/2) * moveSpeed * 0.7 * deltaTime * 60; 
        }
        if (controls.strafeRight) { 
            moveX += Math.cos(gameData.player.angle + Math.PI/2) * moveSpeed * 0.7 * deltaTime * 60; 
            moveY += Math.sin(gameData.player.angle + Math.PI/2) * moveSpeed * 0.7 * deltaTime * 60; 
        }
        
        if (moveX || moveY) {
            const nx = gameData.player.x + moveX, ny = gameData.player.y + moveY;
            if (CollisionSystem.isValidPosition(nx, ny)) { 
                gameData.player.x = nx; 
                gameData.player.y = ny; 
            } else { 
                if (CollisionSystem.isValidPosition(nx, gameData.player.y)) gameData.player.x = nx; 
                if (CollisionSystem.isValidPosition(gameData.player.x, ny)) gameData.player.y = ny; 
            }
        }
        
        if (controls.shoot) { shoot(); }
        
        // Recolección de items
        for (let i = gameData.items.length - 1; i >= 0; i--) {
            const item = gameData.items[i];
            if (!item.collected) {
                const dist = Math.hypot(gameData.player.x - item.x, gameData.player.y - item.y);
                if (dist < 0.8) {
                    if (collectItem(item)) {
                        let particleColor;
                        switch(item.type) {
                            case 'health': particleColor = '#00ff00'; break;
                            case 'ammo': particleColor = '#ffff00'; break;
                            case 'weapon': particleColor = '#ff00ff'; break;
                            default: particleColor = '#ffffff';
                        }
                        particleSystem.createItemPickup(item.x, item.y, particleColor);
                    }
                }
                
                if (Date.now() - item.spawnTime > 30000) {
                    gameData.items.splice(i, 1);
                }
            } else {
                if (Date.now() - item.spawnTime > 5000) {
                    gameData.items.splice(i, 1);
                }
            }
        }
        
        // Actualizar enemigos
        for (let i = gameData.enemies.length - 1; i >= 0; i--) {
            const e = gameData.enemies[i];
            const dist = Math.hypot(gameData.player.x - e.x, gameData.player.y - e.y);
            if (dist < (e.boss ? 10 : 8)) {
                const newX = e.x + (gameData.player.x - e.x) / dist * e.speed * deltaTime * 60;
                const newY = e.y + (gameData.player.y - e.y) / dist * e.speed * deltaTime * 60;
                if (CollisionSystem.isValidPosition(newX, newY)) { 
                    e.x = newX; 
                    e.y = newY; 
                }
                e.attackCooldown -= deltaTime;
                if (e.attackCooldown <= 0 && dist < (e.boss ? 2.0 : 1.5)) { 
                    const damage = e.boss ? 20 : 10; // El jefe hace más daño
                    gameData.player.health -= damage; 
                    gameData.player.lastDamageTime = Date.now();
                    damageEffectTimer = 1.0;
                    e.attackCooldown = e.boss ? 0.8 : 1.0; 
                    soundSystem.playHurt(); 
                    updateHealth(gameData.player.health); 
                    canvas.style.transform = `translate(${(Math.random()-0.5)*10}px, ${(Math.random()-0.5)*10}px)`; 
                    setTimeout(() => canvas.style.transform = '', 100); 
                }
            }
            if (e.health <= 0) { 
                particleSystem.createExplosion(e.x, e.y, e.boss ? 30 : 15); 
                
                if (e.boss) {
                    gameData.score += 1000; // Puntos extra por derrotar al jefe
                    gameData.bossActive = false;
                    gameData.bossDefeated = true;
                    soundSystem.playWaveComplete();
                } else {
                    gameData.score += 100;
                    soundSystem.playHit();
                }
                
                updateScore(gameData.score); 
                
                if (Math.random() < 0.4) {
                    spawnRandomItem();
                }
                
                if (Math.random() < 0.3) { 
                    gameData.player.ammo += difficulties[currentDifficulty].ammoDrop; 
                    updateAmmo(gameData.player.ammo); 
                } 
                gameData.enemies.splice(i, 1); 
            }
        }
        
        // Verificar si se completó la oleada
        if (gameData.enemies.length === 0) { 
            gameData.wave++; 
            
            if (!gameData.bossActive || gameData.bossDefeated) {
                gameData.score += difficulties[currentDifficulty].waveBonus; 
                updateScore(gameData.score); 
                updateWave(gameData.wave); 
                
                if (!gameData.bossActive) {
                    soundSystem.playWaveComplete();
                }
                
                generateEnemies(); 
            }
        }
        
        if (gameData.player.health <= 0) { 
            soundSystem.playGameOver(); 
            alert(`¡GAME OVER!\nPuntuación: ${gameData.score}\nOleada: ${gameData.wave}`); 
            resetGame(); 
        }
        
        particleSystem.update(deltaTime);
    }

    // =============================================
    // BUCLE PRINCIPAL OPTIMIZADO
    // =============================================
    function gameLoop(timestamp) {
        if (!lastTime) lastTime = timestamp;
        const deltaTime = (timestamp - lastTime) / 1000;
        lastTime = timestamp;
        
        if (!gameStarted || gamePaused) { 
            animationFrameId = requestAnimationFrame(gameLoop); 
            return; 
        }
        
        updateGame(deltaTime); 
        renderScene(); 
        animationFrameId = requestAnimationFrame(gameLoop);
    }

    // =============================================
    // FUNCIONES DE INICIALIZACIÓN
    // =============================================
    function resetGame() {
        if (animationFrameId) cancelAnimationFrame(animationFrameId);
        gameData = new GameState();
        updateScore(0); 
        updateHealth(100); 
        updateAmmo(100); 
        updateWave(1);
        updateWeaponDisplay();
        gameStarted = false; 
        gamePaused = false; 
        splashScreen.style.display = 'flex'; 
        setTimeout(() => splashScreen.style.opacity = '1', 50);
        shootCooldown = 0;
        damageEffectTimer = 0;
        bossWarningTimer = 0;
        lastTime = 0;
    }

    async function init() { 
        resizeCanvas(); 
        await loadTextures(); 
        document.addEventListener('click', () => soundSystem.initAudio(), { once: true }); 
        renderMiniMap();
        updateWeaponDisplay();
    }
    
    function startGame() {
        gameStarted = true; 
        splashScreen.style.opacity = '0'; 
        setTimeout(() => splashScreen.style.display = 'none', 500);
        generateEnemies(); 
        soundSystem.playBackgroundMusic(); 
        lastTime = 0;
        animationFrameId = requestAnimationFrame(gameLoop);
        setTimeout(resizeCanvas, 100);
    }

    startButton.addEventListener('click', startGame);
    document.addEventListener('keydown', e => { if (e.key === 'Enter' && !gameStarted) startGame(); });
    window.addEventListener('resize', resizeCanvas);
    window.addEventListener('load', init);
    </script>
</body>
</html>
